/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_H_
# define SHADER_H_

const char *Shader_hlsl =
 "cbuffer _1{matrix _v;matrix _p;float3 _c;int _sx;float3 _d;int _sy;};struct _2{float3 o:POSITION;float4 c:COLOR;float2 tc:TEXCOORD0;};struct _3{float4 o:SV_POSITION;float4 c:COLOR;float2 tc:TEXCOORD0;float3 n:TEXCOORD1;};struct _4{float e[4]:SV_TessFactor;float i[2]:SV_InsideTessFactor;};struct _5{float3 o:POSITION;float4 c:COLOR;float2 tc:TEXCOORD0;float4 _t:TRANSLATION;float4 _r:ROTATION;};struct _6{float4 _t:TRANSLATION;float4 _r:ROTATION;};Texture2D shaderTexture;"
 "SamplerState sampleType;"
 "float random(float a,float b)"
 "{"
   "return frac(sin(dot(float2(a,b),float2(12.9898,78.233)))*43758.5);"
 "}"
 "float3 dnoise2f(float2 p)"
 "{"
   "float i=floor(p.x),j=floor(p.y),u=p.x-i,v=p.y-j,du=30.*u*u*(u*(u-2.)+1.),dv=30.*v*v*(v*(v-2.)+1.);"
   "u=u*u*u*(u*(u*6.-15.)+10.);"
   "v=v*v*v*(v*(v*6.-15.)+10.);"
   "float a=random(i,j),b=random(i+1.,j),c=random(i,j+1.),d=random(i+1.,j+1.),k0=a,k1=b-a,k2=c-a,k3=a-b-c+d;"
   "return float3(k0+k1*u+k2*v+k3*u*v,du*(k1+k3*v),dv*(k2+k3*u));"
 "}"
 "float3 fbm(float2 p,int octaves,float persistence,float gain)"
 "{"
   "float f=0.,w=.5,dx=0.,dz=0.;"
   "for(int i=0;i<octaves;i++)"
     "{"
       "float3 n=dnoise2f(p);"
       "dx+=n[1];"
       "dz+=n[2];"
       "f+=w*n[0]/(1.+dx*dx+dz*dz);"
       "w*=gain;"
       "p*=persistence;"
     "}"
   "return float3(f,dx,dz);"
 "}"
 "_2 VS(_2 input)"
 "{"
   "_2 output;"
   "output.o=input.o;"
   "output.c=input.c;"
   "output.tc=input.tc;"
   "return output;"
 "}"
 "float ClipToScreenSpaceTessellation(float4 clip0,float4 clip1)"
 "{"
   "clip0/=clip0.w;"
   "clip1/=clip1.w;"
   "clip0.xy*=float2(_sx,_sy);"
   "clip1.xy*=float2(_sx,_sy);"
   "const float d=distance(clip0,clip1),tessellatedTriWidth=16;"
   "float t=d/tessellatedTriWidth;"
   "return clamp(t,0,64);"
 "}"
 "float SphereToScreenSpaceTessellation(float3 p0,float3 p1)"
 "{"
   "float3 centre=.5*(p0+p1);"
   "float4 view0=mul(float4(centre,1),_v),view1=view0;"
   "view1.x+=1.;"
   "float4 clip0=mul(view0,_p),clip1=mul(view1,_p);"
   "return ClipToScreenSpaceTessellation(clip0,clip1);"
 "}"
 "bool inFrustum(const float3 pt)"
 "{"
   "float margin=sqrt(2.);"
   "float3 eyeToPt=pt-_c,patch_to_camera_direction_vector=_d*dot(eyeToPt,_d)-eyeToPt,patch_center_realigned=pt+normalize(patch_to_camera_direction_vector)*min(margin,length(patch_to_camera_direction_vector));"
   "float4 patch_screenspace_center=mul(mul(float4(patch_center_realigned,1.),_v),_p);"
   "if(patch_screenspace_center.x/patch_screenspace_center.w>=-1.&&patch_screenspace_center.x/patch_screenspace_center.w<=1.&&patch_screenspace_center.y/patch_screenspace_center.w>=-1.&&patch_screenspace_center.y/patch_screenspace_center.w<=1.&&patch_screenspace_center.w>=0||length(pt-_c)<=margin)"
     "return true;"
   "return false;"
 "}"
 "float4 terrainHeight(float2 uvWorld)"
 "{"
   "return shaderTexture.SampleLevel(sampleType,uvWorld,0)*float4(10.,1.,1.,1.);"
 "}"
 "_4 CPCFT(InputPatch<_2, 4> ip,uint patchId:SV_PrimitiveID)"
 "{"
   "_4 o;"
   "if(distance(ip[0].o,_c)>200)"
     "return o.i[0]=o.i[1]=-1,o.e[0]=o.e[1]=o.e[2]=o.e[3]=-1,o;"
   "float3 v0=ip[0].o+float3(0,terrainHeight(ip[0].tc).x,0),v1=ip[1].o+float3(0,terrainHeight(ip[1].tc).x,0),v2=ip[2].o+float3(0,terrainHeight(ip[2].tc).x,0),v3=ip[3].o+float3(0,terrainHeight(ip[3].tc).x,0);"
   "if(!inFrustum(v0)&&!inFrustum(v1)&&!inFrustum(v2)&&!inFrustum(v3))"
     "o.i[0]=o.i[1]=-1,o.e[0]=o.e[1]=o.e[2]=o.e[3]=-1;"
   "else"
     "{"
       "float e1=SphereToScreenSpaceTessellation(v0,v1),e2=SphereToScreenSpaceTessellation(v1,v2),e3=SphereToScreenSpaceTessellation(v2,v3),e0=SphereToScreenSpaceTessellation(v3,v0);"
       "o.e[0]=e0;"
       "o.e[1]=e1;"
       "o.e[2]=e2;"
       "o.e[3]=e3;"
       "o.i[1]=.5*(e0+e2);"
       "o.i[0]=.5*(e1+e3);"
     "}"
   "return o;"
 "}"
 "_4 CPCFP(InputPatch<_5, 4> ip,uint patchId:SV_PrimitiveID)"
 "{"
   "_4 o;"
   "float3 v0=ip[0].o+ip[0]._t.xyz,v1=ip[1].o+ip[1]._t.xyz,v2=ip[2].o+ip[2]._t.xyz,v3=ip[3].o+ip[3]._t.xyz;"
   "float e1=SphereToScreenSpaceTessellation(v0,v1),e2=SphereToScreenSpaceTessellation(v1,v2),e3=SphereToScreenSpaceTessellation(v2,v3),e0=SphereToScreenSpaceTessellation(v3,v0);"
   "o.e[0]=e0;"
   "o.e[1]=e1;"
   "o.e[2]=e2;"
   "o.e[3]=e3;"
   "o.i[1]=.5*(e0+e2);"
   "o.i[0]=.5*(e1+e3);"
   "return o;"
 "}"
 "[domain(\"quad\")]"
 "[partitioning(\"fractional_even\")]"
 "[outputtopology(\"triangle_cw\")]"
 "[outputcontrolpoints(4)]"
 "[patchconstantfunc(\"CPCFT\")]"
 "_2 HS(InputPatch<_2, 4> patch,uint pointId:SV_OutputControlPointID,uint patchId:SV_PrimitiveID)"
 "{"
   "_2 output;"
   "output.o=patch[pointId].o;"
   "output.tc=patch[pointId].tc;"
   "output.c=patch[pointId].c;"
   "return output;"
 "}"
 "[domain(\"quad\")]"
 "[partitioning(\"fractional_even\")]"
 "[outputtopology(\"triangle_cw\")]"
 "[outputcontrolpoints(4)]"
 "[patchconstantfunc(\"CPCFP\")]"
 "_5 HSP(InputPatch<_5, 4> patch,uint pointId:SV_OutputControlPointID,uint patchId:SV_PrimitiveID)"
 "{"
   "_5 output;"
   "output.o=patch[pointId].o;"
   "output.tc=patch[pointId].tc;"
   "output.c=patch[pointId].c;"
   "output._t=patch[pointId]._t;"
   "output._r=patch[pointId]._r;"
   "return output;"
 "}"
 "[domain(\"quad\")]"
 "_3 DS(_4 input,float2 UV:SV_DomainLocation,const OutputPatch<_2, 4> patch)"
 "{"
   "_3 output;"
   "float2 texCoords=lerp(lerp(patch[0].tc,patch[1].tc,UV.x),lerp(patch[3].tc,patch[2].tc,UV.x),UV.y);"
   "float3 pos=lerp(lerp(patch[0].o,patch[1].o,UV.x),lerp(patch[3].o,patch[2].o,UV.x),UV.y);"
   "pos.y+=terrainHeight(texCoords).x;"
   "output.o=mul(mul(float4(pos,1.f),_v),_p);"
   "output.n=pos;"
   "output.tc=texCoords;"
   "output.c=float4(pos,1.f);"
   "return output;"
 "}"
 "_3 VST(uint vertexId:SV_VertexID)"
 "{"
   "_3 output;"
   "if(vertexId==0)"
     "output.o=float4(-1.,-1.,0.,1.);"
   "else"
     " if(vertexId==1)"
       "output.o=float4(-1.,1.,0.,1.);"
     "else"
       " if(vertexId==2)"
         "output.o=float4(1.,-1.,0.,1.);"
       "else"
         " output.o=float4(1.,1.,0.,1.);"
   "output.tc=output.o.xy*.5+.5;"
   "output.c=float4(1,1,1,1);"
   "output.n=output.o.xyz;"
   "return output;"
 "}"
 "float grassAmount(float4 t)"
 "{"
   "return smoothstep(.6,.9,t.w);"
 "}"
 "float4 PS(_3 input):SV_TARGET"
 "{"
   "float dist=distance(input.n,_c);"
   "float2 uv=input.tc;"
   "float4 t=terrainHeight(uv);"
   "float3 detail1=fbm(uv*10000,4,2.,.5),detail2=dnoise2f(uv*1000),n=normalize(normalize(float3(t.y,2.,t.z)));"
   "float tAmbient=t.x/20.+.25,tDiffuse=max(0,dot(n,normalize(float3(1,1,1))));"
   "float3 ambient=float3(.3,.2,.1)*tAmbient*t.w,dirt=float3(.7,.6,.5),dirt2=float3(.6,.5,.4),stone=float3(.3,.35,.4),grassDark=float3(.18,.22,0),grassBrown=float3(.18,.22,0),grassGreen=float3(.36,.44,0),grass=lerp(lerp(grassGreen,grassDark,detail2.x),grassBrown,detail1.x),ground=lerp(lerp(dirt,dirt2,detail2.x),stone,detail1.x),color=lerp(ground,grass,grassAmount(t)),diffuse=color*tDiffuse,fog=float3(.2,.6,.9);"
   "return float4(lerp(diffuse+ambient,fog,max(0,min(1,dist/200.))),1.);"
 "}"
 "float4 PSH(_3 input):SV_TARGET"
 "{"
   "float3 t=fbm(input.tc*20,10,2.,.5).x;"
   "float2 n=fbm(input.tc*20,3,2.,.5).yz;"
   "float d=normalize(float3(n.x,.5,n.y)).y;"
   "return float4(t.xyz,d);"
 "}"
 "float4 PST(_3 input):SV_TARGET"
 "{"
   "float3 fog=float3(.2,.6,.9);"
   "float dist=distance(input.n,_c);"
   "float3 color=shaderTexture.Sample(sampleType,input.tc).xyz;"
   "return float4(lerp(color,fog,max(0,min(1,dist/200.))),1.);"
 "}";

#endif // SHADER_H_
